/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package java_security;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.DSAPrivateKeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;

public class App {
	
	private static final Charset CHARSET = StandardCharsets.UTF_8;
	private static final int KEYSIZE = 2048;

    public static void main(String[] args) {
        try {
			App app = new App();
			app.computeMessageDigest("SHA-256", "Hello word");
			
			KeyPair keyPair = app.generateKeyPair("DSA");
			
			app.generateAndVerifySignature("SHA256withDSA", "Hello world", keyPair);
			
			app.encryptAndDecryptSymmetric();
		}
		catch (NoSuchAlgorithmException e) {
			System.err.println("No algorith found: " + e.getMessage());
		}
		catch (InvalidKeyException | SignatureException se) {
			System.err.println("Unable to generate and verify signature");
		}
		catch (NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException | InvalidAlgorithmParameterException e) {
			System.err.println("Unable to perform encrypting and decrypting");
		}
    }
    
    /**
     * Describe a procedure to compute a {@link MessageDigest} object
     * @throws NoSuchAlgorithmException 
     */
    public void computeMessageDigest(String algorithm, String data) throws NoSuchAlgorithmException {
    	MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
    	byte[] dataAsBytesArray = data.getBytes(CHARSET);
    	
    	messageDigest.update(dataAsBytesArray);
    	
    	// digest and get the hash
    	byte[] digestMessageAsBytesArray = messageDigest.digest();
    	String hashCode = covertBytesToHex(digestMessageAsBytesArray);
    	
    	System.out.println(String.format("Hash code of '%s' is '%s'", data, hashCode));
    }
    
    private static String covertBytesToHex(byte[] hash) {
    	StringBuilder hexString = new StringBuilder(hash.length * 2);
    	for (int i = 0; i < hash.length; i++) {
			String hex = Integer.toHexString(0xff & hash[i]);
			if (hex.length() == 1) {
				hexString.append('0');
			}
			hexString.append(hex);
		}
    	return hexString.toString();
    }

    public KeyPair generateKeyPair(String algorithm) throws NoSuchAlgorithmException {
    	KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(algorithm);
    	
    	// initialize in algorithm-independent way with the source of randomness is system-provided
    	// it is up to the provider to do about the algorithm-specific parameters to be associated with each of the keys
    	keyPairGenerator.initialize(KEYSIZE);
    	
    	// generate keys
    	return keyPairGenerator.generateKeyPair();
    }
    
    public void generateAndVerifySignature(String algorithm, String data, KeyPair keyPair) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
    	Signature signature = Signature.getInstance(algorithm);

    	// Initialize the object with private key
    	signature.initSign(keyPair.getPrivate());
    	
    	byte[] dataAsBytesArray = data.getBytes(CHARSET);
    	
    	// Update and sign the data
    	signature.update(dataAsBytesArray);
    	byte[] signData = signature.sign();
    	
    	// Reuse the object and init it for verifying
    	signature.initVerify(keyPair.getPublic());
    	
    	// Update and verify the data
    	signature.update(dataAsBytesArray);
    	boolean verifyResult = signature.verify(signData);
    	
    	System.out.println("Signature verify result: " + verifyResult);
    }
    
    public void encryptAndDecryptSymmetric() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException {
    	// First generate a secret key
    	KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
    	keyGenerator.init(128);
    	SecretKey secretKey = keyGenerator.generateKey();
    	
    	// Create an AES cipher in Cipher Block Chaining mode with PKCS5-style padding
    	Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
    	
    	// Initialize the cipher for encryption
    	cipher.init(Cipher.ENCRYPT_MODE, secretKey);
    	
    	// The provided plain text
    	byte[] plainText = "This is just an example".getBytes(CHARSET);
    	
    	// encrypt the plain text
    	byte[] cipherText = cipher.doFinal(plainText);
    	
    	System.out.println("Cipher text in hex string: " + covertBytesToHex(cipherText));
    	
    	// Now do the encryption
    	// First, retrieve the parameters used during encryption to properly initialize the cipher for decryption
    	AlgorithmParameters algorithmParameters = cipher.getParameters();
    	
    	// initialize the same cipher for decryption
    	cipher.init(Cipher.DECRYPT_MODE, secretKey, algorithmParameters);
    	
    	byte[] textAfterDecryption = cipher.doFinal(cipherText);
    	
    	System.out.println("Cipher text after decrypting: " + new String(textAfterDecryption, CHARSET));
    }
}
